package com.onescale.auth.service;

import com.onescale.auth.dto.*;
import com.onescale.auth.entity.RefreshToken;
import com.onescale.auth.entity.User;
import com.onescale.auth.exception.AuthException;
import com.onescale.auth.exception.InvalidTokenException;
import com.onescale.auth.repository.RefreshTokenRepository;
import com.onescale.auth.repository.UserRepository;
import com.onescale.auth.util.JwtUtil;
import jakarta.transaction.Transactional;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.UUID;

/**
 * Core authentication service.
 *
 * The backend never talks to Firebase or any OAuth provider.
 * The frontend is responsible for authenticating the user and
 * extracting their public profile.  This service only:
 *   1. Persists the user row (register)
 *   2. Locates an existing user row (login)
 *   3. Issues backend-signed JWTs (token)
 *   4. Handles refresh / revoke / validate flows
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class AuthService {

    private final UserRepository userRepository;
    private final RefreshTokenRepository refreshTokenRepository;
    private final JwtUtil jwtUtil;

    // ---------------------------------------------------------------
    // REGISTRATION
    // ---------------------------------------------------------------

    /**
     * Create a new user row.
     *
     * A UUID client_id is generated by the entity's @PrePersist hook.
     * The response carries user_id and client_id so the frontend can
     * immediately call /token without a second round-trip.
     *
     * @throws AuthException if email or mobile already exists, or if
     *                       neither email nor mobile is supplied.
     */
    @Transactional
    public UserDto registerUser(RegisterUserDto dto) {
        // At least one contact channel must be present
        if ((dto.getEmail() == null || dto.getEmail().isBlank()) &&
            (dto.getMobileNumber() == null || dto.getMobileNumber().isBlank())) {
            throw new AuthException("At least one of email or mobile number is required");
        }

        // Duplicate checks
        if (dto.getEmail() != null && !dto.getEmail().isBlank() &&
            userRepository.existsByEmail(dto.getEmail())) {
            throw new AuthException("Email is already registered");
        }
        if (dto.getMobileNumber() != null && !dto.getMobileNumber().isBlank() &&
            userRepository.existsByMobileNumber(dto.getMobileNumber())) {
            throw new AuthException("Mobile number is already registered");
        }

        // Derive verification flags from provider
        boolean emailVerified  = dto.getEmail() != null && !dto.getEmail().isBlank();
        boolean mobileVerified = dto.getMobileNumber() != null && !dto.getMobileNumber().isBlank();

        User user = User.builder()
                .fullName(dto.getFullName())
                .email(dto.getEmail())
                .mobileNumber(dto.getMobileNumber())
                .deviceId(dto.getDeviceId())
                .provider(dto.getProvider().toUpperCase())
                .profilePictureUrl(dto.getProfilePictureUrl())
                .isEmailVerified(emailVerified)
                .isMobileVerified(mobileVerified)
                .isActive(true)
                // clientId is set in @PrePersist; do NOT set here so the
                // hook fires and generates a fresh UUID.
                .build();

        User saved = userRepository.save(user);

        log.info("User registered — id={}, clientId={}, provider={}, email={}, mobile={}",
                saved.getId(), saved.getClientId(), saved.getProvider(),
                saved.getEmail(), saved.getMobileNumber());

        return mapUserToDto(saved);
    }

    // ---------------------------------------------------------------
    // LOGIN  (returning user)
    // ---------------------------------------------------------------

    /**
     * Locate an existing user by email or mobile number.
     *
     * The frontend has already re-authenticated the user (e.g. Firebase
     * password flow).  This endpoint updates the device_id and
     * last_login_at on every successful login.
     *
     * @throws AuthException if the user cannot be found or is inactive.
     */
    @Transactional
    public UserDto loginUser(LoginUserDto dto) {
        if ((dto.getEmail() == null || dto.getEmail().isBlank()) &&
            (dto.getMobileNumber() == null || dto.getMobileNumber().isBlank())) {
            throw new AuthException("At least one of email or mobile number is required");
        }

        User user = null;

        if (dto.getEmail() != null && !dto.getEmail().isBlank()) {
            user = userRepository.findByEmail(dto.getEmail()).orElse(null);
        }
        if (user == null && dto.getMobileNumber() != null && !dto.getMobileNumber().isBlank()) {
            user = userRepository.findByMobileNumber(dto.getMobileNumber()).orElse(null);
        }

        if (user == null) {
            throw new AuthException("User not found. Please register first.");
        }

        if (!user.getIsActive()) {
            throw new AuthException("User account is inactive");
        }

        // Persist the latest device_id and login timestamp
        user.setDeviceId(dto.getDeviceId());
        user.setLastLoginAt(LocalDateTime.now());
        userRepository.save(user);

        log.info("User logged in — id={}, clientId={}, deviceId={}",
                user.getId(), user.getClientId(), dto.getDeviceId());

        return mapUserToDto(user);
    }

    // ---------------------------------------------------------------
    // TOKEN GENERATION
    // ---------------------------------------------------------------

    /**
     * Issue a signed access-token + refresh-token pair.
     *
     * Validates that the supplied (userId, clientId, deviceId) triple
     * matches the persisted user row before signing anything.
     *
     * @throws InvalidTokenException if the triple does not match.
     * @throws AuthException         if the user does not exist or is inactive.
     */
    @Transactional
    public AuthResponseDto generateToken(TokenRequestDto dto) {
        User user = userRepository.findById(dto.getUserId())
                .orElseThrow(() -> new AuthException("User not found"));

        if (!user.getIsActive()) {
            throw new AuthException("User account is inactive");
        }

        // client_id must match what the backend issued at registration
        if (!dto.getClientId().equals(user.getClientId())) {
            throw new InvalidTokenException("Invalid client ID");
        }

        // device_id must match the one on file (updated at each login)
        if (!dto.getDeviceId().equals(user.getDeviceId())) {
            throw new InvalidTokenException("Device ID mismatch");
        }

        log.info("Generating tokens — userId={}, clientId={}", user.getId(), user.getClientId());

        return buildAuthResponse(user);
    }

    // ---------------------------------------------------------------
    // REFRESH
    // ---------------------------------------------------------------

    /**
     * Exchange a valid refresh token for a new access token.
     * The original refresh token stays valid until it expires or is revoked.
     */
    @Transactional
    public AuthResponseDto refreshAccessToken(String refreshTokenString) {
        if (!jwtUtil.isRefreshToken(refreshTokenString)) {
            throw new InvalidTokenException("Invalid refresh token type");
        }

        Long userId = jwtUtil.getUserIdFromToken(refreshTokenString);

        RefreshToken refreshToken = refreshTokenRepository.findByToken(refreshTokenString)
                .orElseThrow(() -> new InvalidTokenException("Refresh token not found"));

        if (!refreshToken.isValid()) {
            throw new InvalidTokenException("Refresh token is expired or revoked");
        }

        User user = userRepository.findById(userId)
                .orElseThrow(() -> new AuthException("User not found"));

        String newAccessToken = jwtUtil.generateAccessToken(user);

        log.info("Access token refreshed for user: {}", userId);

        return AuthResponseDto.builder()
                .accessToken(newAccessToken)
                .refreshToken(refreshTokenString)   // reuse the same refresh token
                .tokenType("Bearer")
                .expiresIn(jwtUtil.getAccessTokenExpirationInSeconds())
                .user(mapUserToDto(user))
                .build();
    }

    // ---------------------------------------------------------------
    // REVOKE / LOGOUT
    // ---------------------------------------------------------------

    @Transactional
    public void revokeRefreshToken(String refreshTokenString) {
        RefreshToken refreshToken = refreshTokenRepository.findByToken(refreshTokenString)
                .orElseThrow(() -> new InvalidTokenException("Refresh token not found"));

        refreshToken.setIsRevoked(true);
        refreshToken.setRevokedAt(LocalDateTime.now());
        refreshTokenRepository.save(refreshToken);

        log.info("Refresh token revoked for user: {}", refreshToken.getUser().getId());
    }

    @Transactional
    public void revokeAllUserTokens(Long userId) {
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new AuthException("User not found"));

        refreshTokenRepository.revokeAllUserTokens(user, LocalDateTime.now());
        log.info("All refresh tokens revoked for user: {}", userId);
    }

    // ---------------------------------------------------------------
    // VALIDATE  (for other microservices)
    // ---------------------------------------------------------------

    public TokenValidationDto validateAccessToken(String accessToken) {
        io.jsonwebtoken.Claims claims = jwtUtil.validateToken(accessToken);

        if (!"access".equals(claims.get("tokenType"))) {
            throw new InvalidTokenException("Token is not an access token");
        }

        Long userId = Long.parseLong(claims.getSubject());

        User user = userRepository.findById(userId)
                .orElseThrow(() -> new InvalidTokenException("User not found"));

        if (!user.getIsActive()) {
            throw new InvalidTokenException("User account is not active");
        }

        return TokenValidationDto.builder()
                .isValid(true)
                .userId(userId)
                .email((String) claims.get("email"))
                .mobileNumber((String) claims.get("mobileNumber"))
                .tokenType("custom_jwt")
                .issuedAt(claims.getIssuedAt().getTime() / 1000)
                .expiresAt(claims.getExpiration().getTime() / 1000)
                .build();
    }

    // ---------------------------------------------------------------
    // PRIVATE HELPERS
    // ---------------------------------------------------------------

    /**
     * Create access + refresh tokens, persist the refresh token, and
     * assemble the response DTO.
     */
    private AuthResponseDto buildAuthResponse(User user) {
        String accessToken  = jwtUtil.generateAccessToken(user);
        String refreshToken = jwtUtil.generateRefreshToken(user);

        RefreshToken refreshTokenEntity = RefreshToken.builder()
                .token(refreshToken)
                .user(user)
                .expiresAt(jwtUtil.getRefreshTokenExpirationDate()
                        .toInstant()
                        .atZone(ZoneId.systemDefault())
                        .toLocalDateTime())
                .isRevoked(false)
                .build();

        refreshTokenRepository.save(refreshTokenEntity);

        return AuthResponseDto.builder()
                .accessToken(accessToken)
                .refreshToken(refreshToken)
                .tokenType("Bearer")
                .expiresIn(jwtUtil.getAccessTokenExpirationInSeconds())
                .user(mapUserToDto(user))
                .build();
    }

    private UserDto mapUserToDto(User user) {
        return UserDto.builder()
                .userId(user.getId())
                .clientId(user.getClientId())
                .deviceId(user.getDeviceId())
                .provider(user.getProvider())
                .email(user.getEmail())
                .mobileNumber(user.getMobileNumber())
                .fullName(user.getFullName())
                .profilePictureUrl(user.getProfilePictureUrl())
                .isEmailVerified(user.getIsEmailVerified())
                .isMobileVerified(user.getIsMobileVerified())
                .build();
    }
}
