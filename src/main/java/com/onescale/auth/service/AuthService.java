package com.onescale.auth.service;

import com.onescale.auth.dto.*;
import com.onescale.auth.entity.RefreshToken;
import com.onescale.auth.entity.User;
import com.onescale.auth.exception.AuthException;
import com.onescale.auth.exception.InvalidTokenException;
import com.onescale.auth.repository.RefreshTokenRepository;
import com.onescale.auth.repository.UserRepository;
import com.onescale.auth.util.JwtUtil;
import jakarta.transaction.Transactional;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.UUID;

/**
 * Core authentication service - Standard OAuth2-style auth with password + OAuth support.
 *
 * Two authentication flows:
 *   1. PASSWORD provider: Backend validates email/mobile + password, returns JWT
 *   2. OAuth providers (GOOGLE, FACEBOOK): Frontend authenticates, backend just registers/identifies user
 *
 * All successful logins return JWT tokens directly (no separate /token call needed).
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class AuthService {

    private final UserRepository userRepository;
    private final RefreshTokenRepository refreshTokenRepository;
    private final JwtUtil jwtUtil;
    private final PasswordEncoder passwordEncoder = new BCryptPasswordEncoder();

    // ---------------------------------------------------------------
    // REGISTRATION
    // ---------------------------------------------------------------

    /**
     * Register a new user.
     *
     * For PASSWORD provider: password is required and will be hashed with BCrypt
     * For OAuth providers (GOOGLE, FACEBOOK, etc.): password must be null
     *
     * A UUID client_id is auto-generated by @PrePersist hook.
     * Returns user profile with client_id (the only external user identifier).
     *
     * @throws AuthException if validation fails or email/mobile already exists
     */
    @Transactional
    public UserDto registerUser(RegisterUserDto dto) {
        // At least one contact channel must be present
        if ((dto.getEmail() == null || dto.getEmail().isBlank()) &&
            (dto.getMobileNumber() == null || dto.getMobileNumber().isBlank())) {
            throw new AuthException("At least one of email or mobile number is required");
        }

        String provider = dto.getProvider().toUpperCase();

        // Validate password based on provider
        if ("PASSWORD".equals(provider)) {
            if (dto.getPassword() == null || dto.getPassword().isBlank()) {
                throw new AuthException("Password is required for PASSWORD provider");
            }
        } else {
            // OAuth providers should NOT have a password
            if (dto.getPassword() != null && !dto.getPassword().isBlank()) {
                throw new AuthException("Password must not be provided for OAuth providers");
            }
        }

        // Duplicate checks
        if (dto.getEmail() != null && !dto.getEmail().isBlank() &&
            userRepository.existsByEmail(dto.getEmail())) {
            throw new AuthException("Email is already registered");
        }
        if (dto.getMobileNumber() != null && !dto.getMobileNumber().isBlank() &&
            userRepository.existsByMobileNumber(dto.getMobileNumber())) {
            throw new AuthException("Mobile number is already registered");
        }

        // Hash password if provided (PASSWORD provider only)
        String passwordHash = null;
        if (dto.getPassword() != null && !dto.getPassword().isBlank()) {
            passwordHash = passwordEncoder.encode(dto.getPassword());
        }

        // Derive verification flags from provider
        boolean emailVerified  = dto.getEmail() != null && !dto.getEmail().isBlank();
        boolean mobileVerified = dto.getMobileNumber() != null && !dto.getMobileNumber().isBlank();

        User user = User.builder()
                .fullName(dto.getFullName())
                .email(dto.getEmail())
                .mobileNumber(dto.getMobileNumber())
                .deviceId(dto.getDeviceId())
                .provider(provider)
                .passwordHash(passwordHash)
                .profilePictureUrl(dto.getProfilePictureUrl())
                .isEmailVerified(emailVerified)
                .isMobileVerified(mobileVerified)
                .isActive(true)
                // clientId is set in @PrePersist
                .build();

        User saved = userRepository.save(user);

        log.info("User registered — clientId={}, provider={}, email={}, mobile={}",
                saved.getClientId(), saved.getProvider(), saved.getEmail(), saved.getMobileNumber());

        return mapUserToDto(saved);
    }

    // ---------------------------------------------------------------
    // LOGIN  (returning user)
    // ---------------------------------------------------------------

    /**
     * Authenticate user and issue JWT tokens.
     *
     * For PASSWORD provider users: validates email/mobile + password
     * For OAuth users: This may not be used (OAuth handled on frontend)
     *
     * Returns JWT access token + refresh token on successful authentication.
     *
     * @throws AuthException if credentials are invalid or user is inactive
     */
    @Transactional
    public AuthResponseDto loginUser(LoginUserDto dto) {
        if ((dto.getEmail() == null || dto.getEmail().isBlank()) &&
            (dto.getMobileNumber() == null || dto.getMobileNumber().isBlank())) {
            throw new AuthException("At least one of email or mobile number is required");
        }

        // Find user by email or mobile
        User user = null;
        if (dto.getEmail() != null && !dto.getEmail().isBlank()) {
            user = userRepository.findByEmail(dto.getEmail()).orElse(null);
        }
        if (user == null && dto.getMobileNumber() != null && !dto.getMobileNumber().isBlank()) {
            user = userRepository.findByMobileNumber(dto.getMobileNumber()).orElse(null);
        }

        if (user == null) {
            throw new AuthException("Invalid credentials");
        }

        if (!user.getIsActive()) {
            throw new AuthException("User account is inactive");
        }

        // Validate password for PASSWORD provider
        if ("PASSWORD".equals(user.getProvider())) {
            if (dto.getPassword() == null || dto.getPassword().isBlank()) {
                throw new AuthException("Password is required");
            }
            if (user.getPasswordHash() == null ||
                !passwordEncoder.matches(dto.getPassword(), user.getPasswordHash())) {
                throw new AuthException("Invalid credentials");
            }
        }

        // Update device_id and last login timestamp
        user.setDeviceId(dto.getDeviceId());
        user.setLastLoginAt(LocalDateTime.now());
        userRepository.save(user);

        log.info("User logged in — clientId={}, provider={}, deviceId={}",
                user.getClientId(), user.getProvider(), dto.getDeviceId());

        // Generate and return JWT tokens
        return buildAuthResponse(user);
    }

    // ---------------------------------------------------------------
    // TOKEN GENERATION
    // ---------------------------------------------------------------

    /**
     * Issue a signed access-token + refresh-token pair.
     *
     * @deprecated Use loginUser() instead which validates credentials and returns tokens.
     *
     * Validates (clientId, deviceId) pair before issuing tokens.
     * Kept for backward compatibility only.
     *
     * @throws InvalidTokenException if deviceId doesn't match
     * @throws AuthException if user not found or inactive
     */
    @Deprecated
    @Transactional
    public AuthResponseDto generateToken(TokenRequestDto dto) {
        User user = userRepository.findByClientId(dto.getClientId())
                .orElseThrow(() -> new AuthException("User not found"));

        if (!user.getIsActive()) {
            throw new AuthException("User account is inactive");
        }

        // device_id must match the one on file
        if (!dto.getDeviceId().equals(user.getDeviceId())) {
            throw new InvalidTokenException("Device ID mismatch");
        }

        log.info("Generating tokens (deprecated endpoint) — clientId={}", user.getClientId());

        return buildAuthResponse(user);
    }

    // ---------------------------------------------------------------
    // REFRESH
    // ---------------------------------------------------------------

    /**
     * Exchange a valid refresh token for a new access token.
     * The original refresh token stays valid until it expires or is revoked.
     */
    @Transactional
    public AuthResponseDto refreshAccessToken(String refreshTokenString) {
        if (!jwtUtil.isRefreshToken(refreshTokenString)) {
            throw new InvalidTokenException("Invalid refresh token type");
        }

        String clientId = jwtUtil.getClientIdFromToken(refreshTokenString);

        RefreshToken refreshToken = refreshTokenRepository.findByToken(refreshTokenString)
                .orElseThrow(() -> new InvalidTokenException("Refresh token not found"));

        if (!refreshToken.isValid()) {
            throw new InvalidTokenException("Refresh token is expired or revoked");
        }

        User user = userRepository.findByClientId(clientId)
                .orElseThrow(() -> new AuthException("User not found"));

        String newAccessToken = jwtUtil.generateAccessToken(user);

        log.info("Access token refreshed for client: {}", clientId);

        return AuthResponseDto.builder()
                .accessToken(newAccessToken)
                .refreshToken(refreshTokenString)   // reuse the same refresh token
                .tokenType("Bearer")
                .expiresIn(jwtUtil.getAccessTokenExpirationInSeconds())
                .user(mapUserToDto(user))
                .build();
    }

    // ---------------------------------------------------------------
    // REVOKE / LOGOUT
    // ---------------------------------------------------------------

    @Transactional
    public void revokeRefreshToken(String refreshTokenString) {
        RefreshToken refreshToken = refreshTokenRepository.findByToken(refreshTokenString)
                .orElseThrow(() -> new InvalidTokenException("Refresh token not found"));

        refreshToken.setIsRevoked(true);
        refreshToken.setRevokedAt(LocalDateTime.now());
        refreshTokenRepository.save(refreshToken);

        log.info("Refresh token revoked for user: {}", refreshToken.getUser().getId());
    }

    @Transactional
    public void revokeAllUserTokens(String clientId) {
        User user = userRepository.findByClientId(clientId)
                .orElseThrow(() -> new AuthException("User not found"));

        refreshTokenRepository.revokeAllUserTokens(user, LocalDateTime.now());
        log.info("All refresh tokens revoked for client: {}", clientId);
    }

    // ---------------------------------------------------------------
    // VALIDATE  (for other microservices)
    // ---------------------------------------------------------------

    public TokenValidationDto validateAccessToken(String accessToken) {
        io.jsonwebtoken.Claims claims = jwtUtil.validateToken(accessToken);

        if (!"access".equals(claims.get("tokenType"))) {
            throw new InvalidTokenException("Token is not an access token");
        }

        String clientId = claims.getSubject();  // subject is now client_id

        User user = userRepository.findByClientId(clientId)
                .orElseThrow(() -> new InvalidTokenException("User not found"));

        if (!user.getIsActive()) {
            throw new InvalidTokenException("User account is not active");
        }

        return TokenValidationDto.builder()
                .isValid(true)
                .clientId(clientId)
                .email((String) claims.get("email"))
                .mobileNumber((String) claims.get("mobileNumber"))
                .tokenType("custom_jwt")
                .issuedAt(claims.getIssuedAt().getTime() / 1000)
                .expiresAt(claims.getExpiration().getTime() / 1000)
                .build();
    }

    // ---------------------------------------------------------------
    // PRIVATE HELPERS
    // ---------------------------------------------------------------

    /**
     * Create access + refresh tokens, persist the refresh token, and
     * assemble the response DTO.
     */
    private AuthResponseDto buildAuthResponse(User user) {
        String accessToken  = jwtUtil.generateAccessToken(user);
        String refreshToken = jwtUtil.generateRefreshToken(user);

        RefreshToken refreshTokenEntity = RefreshToken.builder()
                .token(refreshToken)
                .user(user)
                .expiresAt(jwtUtil.getRefreshTokenExpirationDate()
                        .toInstant()
                        .atZone(ZoneId.systemDefault())
                        .toLocalDateTime())
                .isRevoked(false)
                .build();

        refreshTokenRepository.save(refreshTokenEntity);

        return AuthResponseDto.builder()
                .accessToken(accessToken)
                .refreshToken(refreshToken)
                .tokenType("Bearer")
                .expiresIn(jwtUtil.getAccessTokenExpirationInSeconds())
                .user(mapUserToDto(user))
                .build();
    }

    private UserDto mapUserToDto(User user) {
        return UserDto.builder()
                .clientId(user.getClientId())  // Only external identifier
                .deviceId(user.getDeviceId())
                .provider(user.getProvider())
                .email(user.getEmail())
                .mobileNumber(user.getMobileNumber())
                .fullName(user.getFullName())
                .profilePictureUrl(user.getProfilePictureUrl())
                .isEmailVerified(user.getIsEmailVerified())
                .isMobileVerified(user.getIsMobileVerified())
                .build();
    }
}
